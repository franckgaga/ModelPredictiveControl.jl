var documenterSearchIndex = {"docs":
[{"location":"state_estim/#State-estimator-design","page":"State estimator design","title":"State estimator design","text":"","category":"section"},{"location":"state_estim/","page":"State estimator design","title":"State estimator design","text":"This package includes many state estimators (or state observer), both for deterministic and stochastic systems. ","category":"page"},{"location":"state_estim/","page":"State estimator design","title":"State estimator design","text":"The estimator are all implemented in the predictor form (a.k.a. observer form), that is,  they all estimates at each discrete time k the states of the next period  mathbfx_k(k+1). This form comes in handy for control applications since the  estimations come after the controller computations, without introducing any additional delays.  In contrast, the filter form that estimates mathbfx_k(k) is sometimes slightly more  accurate.","category":"page"},{"location":"state_estim/","page":"State estimator design","title":"State estimator design","text":"info: Info\nAll the state estimators support measured mathbfy^m and unmeasured  mathbfy^u model outputs, where mathbfy refers to all of them.","category":"page"},{"location":"state_estim/#StateEstimator-types","page":"State estimator design","title":"StateEstimator types","text":"","category":"section"},{"location":"state_estim/","page":"State estimator design","title":"State estimator design","text":"StateEstimator","category":"page"},{"location":"state_estim/#ModelPredictiveControl.StateEstimator","page":"State estimator design","title":"ModelPredictiveControl.StateEstimator","text":"Abstract supertype of all state estimators.\n\n\n\n(estim::StateEstimator)(d=Float64[])\n\nFunctor allowing callable StateEstimator object as an alias for evaloutput.\n\nExamples\n\njulia> kf = KalmanFilter(setop!(LinModel(tf(3, [10, 1]), 2), yop=[20]));\n\njulia> ŷ = kf() \n1-element Vector{Float64}:\n 20.0\n\n\n\n\n\n","category":"type"},{"location":"state_estim/#InternalModel","page":"State estimator design","title":"InternalModel","text":"","category":"section"},{"location":"state_estim/","page":"State estimator design","title":"State estimator design","text":"InternalModel","category":"page"},{"location":"state_estim/#ModelPredictiveControl.InternalModel","page":"State estimator design","title":"ModelPredictiveControl.InternalModel","text":"InternalModel(model::SimModel; i_ym=1:model.ny, stoch_ym=ss(1,1,1,1,model.Ts).*I)\n\nConstruct an InternalModel estimator based on model (LinModel or NonLinModel).\n\ni_ym provides the model output indices that are measured mathbfy^m, the rest are  unmeasured mathbfy^u. model evaluates the deterministic predictions  mathbfy_d, and stoch_ym, the stochastic predictions of the measured outputs  mathbfy_s^m (the unmeasured ones being mathbfy_s^u=0). The predicted outputs sum both values : mathbfy = y_d + y_s.\n\nwarning: Warning\nInternalModel estimator does not work if model is integrating or unstable. The  constructor verifies these aspects for LinModel but not for NonLinModel. Uses any  other state estimator in such cases.\n\nSee also LinModel, NonLinModel\n\nExamples\n\njulia> estim = InternalModel(LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5), i_ym=[2])\nInternalModel state estimator with a sample time Ts = 0.5 s and:\n 1 manipulated inputs u\n 2 states x̂\n 1 measured outputs ym\n 1 unmeasured outputs yu\n 0 measured disturbances d\n\nExtended Help\n\nstoch_ym is a TransferFunction or StateSpace model that hypothetically filters a zero  mean white noise vector. Its default value supposes 1 integrator per measured outputs,  assuming that the current stochastic estimate mathbfy_s^m(k) = mathbfy^m(k) -  mathbfy_d^m(k) will be constant in the future. This is the dynamic matrix control (DMC)  strategy, which is simple but sometimes too aggressive. Additional poles and zeros in  stoch_ym can mitigate this.\n\n\n\n\n\n","category":"type"},{"location":"state_estim/#Luenberger","page":"State estimator design","title":"Luenberger","text":"","category":"section"},{"location":"state_estim/#SteadyKalmanFilter","page":"State estimator design","title":"SteadyKalmanFilter","text":"","category":"section"},{"location":"state_estim/","page":"State estimator design","title":"State estimator design","text":"SteadyKalmanFilter","category":"page"},{"location":"state_estim/#ModelPredictiveControl.SteadyKalmanFilter","page":"State estimator design","title":"ModelPredictiveControl.SteadyKalmanFilter","text":"SteadyKalmanFilter(model::LinModel; <keyword arguments>)\n\nConstruct a SteadyKalmanFilter (asymptotic) based on the LinModel model.\n\nThe steady-state Kalman filter is based on the process model :\n\nbeginaligned\n    mathbfx(k+1) = \n            mathbfA x(k) + mathbfB_u u(k) + mathbfB_d d(k) + mathbfw(k) \n    mathbfy^m(k) = mathbfC^m x(k) + mathbfD_d^m d(k) + mathbfv(k) \n    mathbfy^u(k) = mathbfC^u x(k) + mathbfD_d^u d(k)\nendaligned\n\nwith sensor mathbfv(k) and process mathbfw(k) noises as zero mean white noise  processes, with a respective covariance of mathbfR and mathbfQ. The arguments  are in standard deviations σ, i.e. same units than outputs and states. The matrices  mathbfA B_u B_d C D_d are model matrices augmented with the stochastic model,  which is specified by the numbers of output integrator nint_ym. Likewise, the covariance matrices are augmented with mathbfQ = textdiag(Q Q_int) and mathbfR = R. The matrices mathbfC^m D_d^m are the rows of mathbfC D_d that correspond to  measured outputs mathbfy^m (and unmeasured ones for mathbfC^u D_d^u).\n\nArguments\n\nmodel::LinModel : (deterministic) model for the estimations.\ni_ym=1:model.ny : model output indices that are measured mathbfy^m, the rest    are unmeasured mathbfy^u.\nσQ=fill(0.1,model.nx) : main diagonal of the process noise covariance mathbfQ of   model, specified as a standard deviation vector.\nσR=fill(0.1,length(i_ym)) : main diagonal of the sensor noise covariance mathbfR   of model measured outputs, specified as a standard deviation vector.\nnint_ym=fill(1,length(i_ym)) : integrator quantity per measured outputs (vector) for the    stochastic model, use nint_ym=0 for no integrator at all.\nσQ_int=fill(0.1,sum(nint_ym)) : same than σQ but for the stochastic model covariance   mathbfQ_int (composed of output integrators)\n\nExtended Help\n\nThe model augmentation with nint_ym vector produces the integral action when the estimator is used in a controller as state feedback (a.k.a. offset-free control). The default is 1  integrator per measured outputs. More than 1 integrator is interesting only when model is  integrating or unstable, or when the unmeasured output disturbances are \"ramp-like\". See  augment_model.\n\ntip: Tip\nIncreasing σQ_int values increases the integral action \"gain\".\n\n\n\n\n\n","category":"type"},{"location":"state_estim/#KalmanFilter","page":"State estimator design","title":"KalmanFilter","text":"","category":"section"},{"location":"state_estim/","page":"State estimator design","title":"State estimator design","text":"KalmanFilter","category":"page"},{"location":"state_estim/#ModelPredictiveControl.KalmanFilter","page":"State estimator design","title":"ModelPredictiveControl.KalmanFilter","text":"KalmanFilter(model::LinModel; <keyword arguments>)\n\nConstruct a time-varying KalmanFilter based on the LinModel model.\n\nThe process model is identical to SteadyKalmanFilter.\n\nArguments\n\nmodel::LinModel : (deterministic) model for the estimations.\nσP0=fill(10,model.nx) : main diagonal of the initial estimate covariance    mathbfP(0), specified as a standard deviation vector.\nσP0_int=fill(10,sum(nint_ym)) : same than σP0 but for the stochastic model   covariance mathbfP_int(0) (composed of output integrators).\n<keyword arguments> of SteadyKalmanFilter\n\n\n\n\n\n","category":"type"},{"location":"state_estim/#UnscentedKalmanFilter","page":"State estimator design","title":"UnscentedKalmanFilter","text":"","category":"section"},{"location":"state_estim/#MovingHorizonEstimator","page":"State estimator design","title":"MovingHorizonEstimator","text":"","category":"section"},{"location":"state_estim/#StateEstimator-functions","page":"State estimator design","title":"StateEstimator functions","text":"","category":"section"},{"location":"state_estim/","page":"State estimator design","title":"State estimator design","text":"initstate!\nupdatestate!\nevaloutput\nsetstate!","category":"page"},{"location":"state_estim/#ModelPredictiveControl.initstate!","page":"State estimator design","title":"ModelPredictiveControl.initstate!","text":"initstate!(estim::StateEstimator, u, ym, d=Float64[])\n\nInit estim.x̂ states from current inputs u, measured outputs ym and disturbances d.\n\nThe method tries to find a good steady-state to initialize estim.x̂ estimate :\n\nIf estim.model is a LinModel, it evaluates estim.model steady-state with  current inputs u and measured disturbances d, and saves the result to estim.x̂[1:nx].\nIf estim.model is a NonLinModel, the current deterministic states  estim.x̂[1:nx] are left unchanged (use setstate! to manually modify them). \n\nIt then estimates the measured outputs ŷm from these states, and the residual offset with  current measured outputs (ym - ŷm) initializes the integrators of the stochastic model. This approach ensures that mathbfy^m(0) = mathbfy^m(0). For LinModel, it  also ensures that the estimator starts at steady-state, resulting in a bumpless manual to  automatic transfer for control applications. \n\n\n\n\n\ninitstate!(estim::InternalModel, u, ym, d=Float64[])\n\nInit estim.x̂d / x̂s states from current inputs u, meas. outputs ym and disturb. d.\n\nThe deterministic state estim.x̂d initialization method is identical to  initstate!(::StateEstimator). The stochastic states estim.x̂s are init at 0. \n\n\n\n\n\ninitstate!(estim::KalmanFilter, u, ym, d=Float64[])\n\nInitialize covariance estim.P̂ and invoke initstate!(::StateEstimator).\n\n\n\n\n\n","category":"function"},{"location":"state_estim/#ModelPredictiveControl.updatestate!","page":"State estimator design","title":"ModelPredictiveControl.updatestate!","text":"updatestate!(model::SimModel, u, d=Float64[])\n\nUpdate model.x states with current inputs u and measured disturbances d.\n\n\n\n\n\nupdatestate!(estim::InternalModel, u, ym, d=Float64[])\n\nUpdate estim.x̂ \\ x̂d \\ x̂s with current inputs u, measured outputs ym and dist. d.\n\n\n\n\n\nupdatestate!(estim::SteadyKalmanFilter, u, ym, d=Float64[])\n\nUpdate estim.x̂ with current inputs u, measured outputs ym and dist. d.\n\n\n\n\n\nupdatestate!(estim::KalmanFilter, u, ym, d=Float64[])\n\nUpdate estim.x̂ \\ P̂ with current inputs u, measured outputs ym and dist. d.\n\n\n\n\n\n","category":"function"},{"location":"state_estim/#ModelPredictiveControl.evaloutput","page":"State estimator design","title":"ModelPredictiveControl.evaloutput","text":"evaloutput(model::SimModel, d=Float64[])\n\nEvaluate SimModel outputs y from model.x states and measured disturbances d.\n\n\n\n\n\nevaloutput(estim::InternalModel, ym, d=Float64[])\n\nEvaluate InternalModel outputs ̂ŷ from estim.x̂d states.\n\nym and d are current measured outputs and disturbances, respectively. InternalModel  estimator needs current measured outputs mathbfy^m(k) to estimate its outputs  mathbfy(k), since the strategy imposes that mathbfy^m(k) = mathbfy^m(k)  is always true. \n\n\n\n\n\nevaloutput(estim::Union{SteadyKalmanFilter, KalmanFilter}, d=Float64[])\n\nEvaluate Kalman filter outputs ̂ŷ from estim.x̂ states and current disturbances d.\n\n\n\n\n\n","category":"function"},{"location":"state_estim/#ModelPredictiveControl.setstate!","page":"State estimator design","title":"ModelPredictiveControl.setstate!","text":"setstate!(model::SimModel, x)\n\nSet model.x states to values specified by x. \n\n\n\n\n\nsetstate!(estim::StateEstimator, x̂)\n\nSet estim.x̂ states to values specified by x̂. \n\n\n\n\n\n","category":"function"},{"location":"state_estim/#Advanced-Topics","page":"State estimator design","title":"Advanced Topics","text":"","category":"section"},{"location":"state_estim/#Internals","page":"State estimator design","title":"Internals","text":"","category":"section"},{"location":"state_estim/","page":"State estimator design","title":"State estimator design","text":"ModelPredictiveControl.init_internalmodel\nModelPredictiveControl.init_estimstoch\nModelPredictiveControl.augment_model","category":"page"},{"location":"state_estim/#ModelPredictiveControl.init_internalmodel","page":"State estimator design","title":"ModelPredictiveControl.init_internalmodel","text":"init_internalmodel(As, Bs, Cs, Ds)\n\nCalc stochastic model update matrices Âs and B̂s for InternalModel estimator.\n\nAs, Bs, Cs and Ds are the stochastic model matrices :\n\nbeginaligned\n    mathbfx_s(k+1) = mathbfA_s x_s(k) + mathbfB_s e(k) \n    mathbfy_s(k)   = mathbfC_s x_s(k) + mathbfD_s e(k)\nendaligned\n\nwhere mathbfe(k) is conceptual and unknown zero mean white noise. Its optimal estimation is mathbfe=0, the expected value. Thus, the Âs and B̂s matrices that  optimally update the stochastic estimate mathbfx_s are:\n\nbeginaligned\n    mathbfx_s(k+1) \n        = mathbf(A_s - B_s D_s^-1 C_s) x_s(k) + mathbf(B_s D_s^-1) y_s(k) \n        = mathbfA_s x_s(k) + mathbfB_s y_s(k)\nendaligned\n\nwith current stochastic outputs estimation mathbfy_s(k), composed of the measured  mathbfy_s^m(k) = mathbfy^m(k) - mathbfy_d^m(k) and unmeasured  mathbfy_s^u = 0 outputs. See [1].\n\n[1]: Desbiens, A., D. Hodouin & É. Plamondon. 2000, \"Global predictive control : a unified control structure for decoupling setpoint tracking, feedforward compensation and  disturbance rejection dynamics\", IEE Proceedings - Control Theory and Applications,  vol. 147, no 4, https://doi.org/10.1049/ip-cta:20000443, p. 465–475, ISSN 1350-2379.\n\n\n\n\n\n","category":"function"},{"location":"state_estim/#ModelPredictiveControl.init_estimstoch","page":"State estimator design","title":"ModelPredictiveControl.init_estimstoch","text":"init_estimstoch(model::SimModel, i_ym, nint_ym::Vector{Int})\n\nCalc stochastic model matrices from output integrators specifications for state estimation.\n\nFor closed-loop state estimators. nint_ym is a vector providing how many integrator should  be added for each measured output mathbfy^m. The argument generates the Asm and  Csm matrices:\n\nbeginaligned\nmathbfx_s(k+1) = mathbfA_s^m x_s(k) + mathbfB_s^m e(k) \nmathbfy_s^m(k) = mathbfC_s^m x_s(k)\nendaligned\n\nwhere mathbfe(k) is conceptual and unknown zero mean white noise. mathbfB_s^m is not used for closed-loop state estimators thus ignored.\n\n\n\n\n\n","category":"function"},{"location":"state_estim/#ModelPredictiveControl.augment_model","page":"State estimator design","title":"ModelPredictiveControl.augment_model","text":"augment_model(model::LinModel, As, Cs)\n\nAugment LinModel state-space matrices with the stochastic ones As and Cs.\n\nIf mathbfx_d are model.x states, and mathbfx_s, the states defined at init_estimstoch, we define an augmented state vector mathbfx =   beginsmallmatrix mathbfx_d  mathbfx_s endsmallmatrix . The function returns the augmented model matrices Â, B̂u, Ĉ, B̂d and D̂d:\n\nbeginaligned\n    mathbfx(k+1) = mathbfA x(k) + mathbfB_u u(k) + mathbfB_d d(k) \n    mathbfy(k)   = mathbfC x(k) + mathbfD_d d(k)\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"predictive_control/#Model-predictive-controller-design","page":"Model predictive controller design","title":"Model predictive controller design","text":"","category":"section"},{"location":"predictive_control/","page":"Model predictive controller design","title":"Model predictive controller design","text":"asddas","category":"page"},{"location":"predictive_control/#PredictiveController-functions-and-types","page":"Model predictive controller design","title":"PredictiveController functions and types","text":"","category":"section"},{"location":"predictive_control/","page":"Model predictive controller design","title":"Model predictive controller design","text":"LinMPC","category":"page"},{"location":"predictive_control/#ModelPredictiveControl.LinMPC","page":"Model predictive controller design","title":"ModelPredictiveControl.LinMPC","text":"LinMPC(model::LinModel; <keyword arguments>)\n\nConstruct a linear predictive controller LinMPC based on LinModel model.\n\nThe controller minimizes the following objective function at each discrete time k:\n\nmin_mathbfΔU ϵ   mathbf(R_y - Y) mathbfM_H_p mathbf(R_y - Y)  + \n                             mathbf(ΔU) mathbfN_H_c mathbf(ΔU)  +\n                        mathbf(R_u - U) mathbfL_H_p mathbf(R_u - U)  + Cϵ^2\n\nin which :\n\nH_p : prediction horizon \nH_c : control horizon\nmathbfΔU : manipulated input increments over H_c\nmathbfY : predicted outputs over H_p\nmathbfU : manipulated inputs over H_p\nmathbfR_y : predicted output setpoints over H_p\nmathbfR_u : predicted manipulated input setpoints over H_p\nmathbfM_H_p = textdiagmathbf(MMM) : output setpoint tracking weights\nmathbfN_H_c = textdiagmathbf(NNN) : manipulated input increment weights\nmathbfL_H_p = textdiagmathbf(LLL) : manipulated input setpoint tracking weights\nC : slack variable weight\nϵ : slack variable for constraint softening\n\nThe mathbfΔU vector includes the manipulated input increments mathbfΔu(k+j) =  mathbfu(k+j) - mathbfu(k+j-1) from j=0 to H_c-1, the mathbfY vector,  the output predictions mathbfy(k+j) from j=1 to H_p, and the mathbfU  vector, the manipulated inputs mathbfu(k+j) from j=0 to H_p-1. The  manipulated input setpoint predictions mathbfR_u are constant at mathbfr_u`.\n\nThis method uses the default state estimator, a SteadyKalmanFilter with default arguments.\n\nArguments\n\nmodel::LinModel : model used for controller predictions and state estimations.\nHp=10+nk: prediction horizon H_p, nk is the number of delays in model.\nHc=2 : control horizon H_c.\nMwt=fill(1.0,model.ny) : main diagonal of mathbfM weight matrix (vector)\nNwt=fill(0.1,model.nu) : main diagonal of mathbfN weight matrix (vector)\nLwt=fill(0.0,model.nu) : main diagonal of mathbfL weight matrix (vector)\nCwt=1e5 : slack variable weight C (scalar), use Cwt=Inf for hard constraints only\nru=model.uop: manipulated input setpoints mathbfr_u (vector)\n\nExtended Help\n\nManipulated inputs setpoints mathbfr_u are not common but they can be interesting for over-actuated systems (e.g. prioritize solutions with lower economical costs). The  default Lwt value implies that this feature is disabled by default.\n\n\n\n\n\nLinMPC(estim::StateEstimator; <keyword arguments>)\n\nUse custom state estimator estim to construct LinMPC.\n\nestim.model must be a LinModel. Else, a NonLinMPC is required. \n\n\n\n\n\n","category":"type"},{"location":"predictive_control/","page":"Model predictive controller design","title":"Model predictive controller design","text":"setconstraint!","category":"page"},{"location":"predictive_control/#ModelPredictiveControl.setconstraint!","page":"Model predictive controller design","title":"ModelPredictiveControl.setconstraint!","text":"setconstraint!(mpc::PredictiveController; <keyword arguments>)\n\nSet the constraint parameters of mpc predictive controller.\n\nThe predictive controllers support both soft and hard constraints, defined by:\n\nbeginalignat*3\n    mathbfu_min  - c_u_min  ϵ  mathbfu(k+j)   mathbfu_max  + c_u_max  ϵ qquad j = 0 1  H_c - 1 \n    mathbfΔu_min - c_Δu_min ϵ  mathbfΔu(k+j)  mathbfΔu_max + c_Δu_max ϵ qquad j = 0 1  H_c - 1 \n    mathbfy_min  - c_y_min  ϵ  mathbfy(k+j)   mathbfy_max  + c_y_max  ϵ qquad j = 1 2  H_p \nendalignat*\n\nand also ϵ  0. All the constraint parameters are vector. Use ±Inf values when there  is no bound. The constraint softness parameters mathbfc, also called equal concern  for relaxation, are non-negative values that specify the softness of the associated bound.  Use 0.0 values for hard constraints. The predicted output constraints mathbfy_min  and mathbfy_max are soft by default.\n\nArguments\n\ninfo: Info\nThe default constraints are mentioned here for clarity but omitting a keyword argument  will not re-assign to its default value (defaults are set at construction only).\n\numin=fill(-Inf,nu) : manipulated input lower bounds mathbfu_min \numax=fill(+Inf,nu) : manipulated input upper bounds mathbfu_max \nΔumin=fill(-Inf,nu) : manipulated input increment lower bounds mathbfΔu_min \nΔumax=fill(+Inf,nu) : manipulated input increment upper bounds mathbfΔu_max \nŷmin=fill(-Inf,ny) : predicted output lower bounds mathbfy_min \nŷmax=fill(+Inf,ny) : predicted output upper bounds mathbfy_max \nc_umin=fill(0.0,nu) : umin softness weights mathbfc_u_min \nc_umax=fill(0.0,nu) : umax softness weights mathbfc_u_max \nc_Δumin=fill(0.0,nu) : Δumin softness weights mathbfc_Δu_min \nc_Δumax=fill(0.0,nu) : Δumax softness weights mathbfc_Δu_max \nc_ŷmin=fill(1.0,ny) : ŷmin softness weights mathbfc_y_min \nc_ŷmax=fill(1.0,ny) : ŷmax softness weights mathbfc_y_max\n\n\n\n\n\n","category":"function"},{"location":"predictive_control/#Advanced-Topics","page":"Model predictive controller design","title":"Advanced Topics","text":"","category":"section"},{"location":"predictive_control/#Internals","page":"Model predictive controller design","title":"Internals","text":"","category":"section"},{"location":"predictive_control/","page":"Model predictive controller design","title":"Model predictive controller design","text":"ModelPredictiveControl.init_deterpred\nModelPredictiveControl.init_ΔUtoU\nModelPredictiveControl.augment_slack\nModelPredictiveControl.init_quadprog\nModelPredictiveControl.init_stochpred","category":"page"},{"location":"predictive_control/#ModelPredictiveControl.init_deterpred","page":"Model predictive controller design","title":"ModelPredictiveControl.init_deterpred","text":"init_deterpred(model::LinModel, Hp, Hc)\n\nConstruct deterministic prediction matrices for LinModel model.\n\nThe linear model predictions are evaluated by :\n\nbeginaligned\n    mathbfY = mathbfE ΔU + mathbfG d(k) + mathbfJ D + mathbfK_d x_d(k) \n                                                  + mathbfP u(k-1) + mathbfY_s \n               = mathbfE ΔU + mathbfF\nendaligned\n\nwhere predicted outputs mathbfY, stochastic outputs mathbfY_s, and  disturbances mathbfD are from k + 1 to k + H_p. Input increments  mathbfΔU are from k to k + H_c - 1. Deterministic state estimates  mathbfx_d(k) are extracted from current estimates mathbfx_k-1(k). Operating points on u, d and y are omitted in above equation.\n\nnote: Note\nStochastic predictions mathbfY_s are calculated separately (see  init_stochpred) and added to mathbfF matrix to support internal model  structure and reduce NonLinMPC computational costs.\n\n\n\n\n\n","category":"function"},{"location":"predictive_control/#ModelPredictiveControl.init_ΔUtoU","page":"Model predictive controller design","title":"ModelPredictiveControl.init_ΔUtoU","text":"init_ΔUtoU(nu, Hp, Hc, C, c_Umin, c_Umax)\n\nInit manipulated input increments to inputs conversion matrices.\n\nThe conversion from the input increments mathbfΔU to manipulated inputs over H_p  and H_c are calculated by:\n\nbeginaligned\nmathbfU = \n    mathbfU_H_p = mathbfS_H_p mathbfΔU + mathbfT_H_p mathbfu(k-1) \n    mathbfU_H_c = mathbfS_H_c mathbfΔU + mathbfT_H_c mathbfu(k-1)\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"predictive_control/#ModelPredictiveControl.augment_slack","page":"Model predictive controller design","title":"ModelPredictiveControl.augment_slack","text":"augment_slack(Hp, Hc, ΔUmin, ΔUmax, E, S_Hp, S_Hc, C, c_Umin, c_Umax, c_Ŷmin, c_Ŷmax)\n\nAugment linear model deterministic prediction matrices with slack variable ϵ.\n\nDenoting the input increments augmented with the slack variable  mathbfΔU = beginsmallmatrix mathbfΔU  ϵ endsmallmatrix,  it returns the augmented conversion matrices mathbfS_H_p and mathbfS_H_c, similar to the ones described at init_ΔUtoU. It also returns mathbfE  to predict the outputs mathbfY = E ΔU + F, and the mathbfA matrices for  the inequality constraints:\n\nbeginbmatrix \n    mathbfA_u_min  \n    mathbfA_u_max \n    mathbfA_y_min  \n    mathbfA_y_max\nendbmatrix mathbfΔU \nbeginbmatrix\n    + mathbfT_H_c mathbfu(k-1) - mathbfU_min \n    - mathbfT_H_c mathbfu(k-1) + mathbfU_max \n    + mathbfF_l - mathbfY_min \n    - mathbfF_l + mathbfY_max\nendbmatrix\n\n\n\n\n\n","category":"function"},{"location":"predictive_control/#ModelPredictiveControl.init_quadprog","page":"Model predictive controller design","title":"ModelPredictiveControl.init_quadprog","text":"init_quadprog(E, S_Hp, M_Hp, N_Hc, L_Hp)\n\nInit quadratic programming (optimization) matrix.\n\nQ is the quadratic programming matrix in general form. It is constant if the model and  objective function weights are linear and time invariant (LTI). The quadratic programming  p vector needs recalculation each control iteration.  \n\n\n\n\n\n","category":"function"},{"location":"predictive_control/#ModelPredictiveControl.init_stochpred","page":"Model predictive controller design","title":"ModelPredictiveControl.init_stochpred","text":"init_stochpred(estim::StateEstimator, Hp)\n\nInit the stochastic prediction matrix Ks from estim estimator for predictive control.\n\nmathbfK_s is the prediction matrix of the stochastic model (composed exclusively of  integrators):\n\n    mathbfY_s = mathbfK_s x_s(k)\n\nThe stochastic predictions mathbfY_s are the integrator outputs from k+1 to  k+H_p. mathbfx_s(k) is extracted from current estimates mathbfx_k-1(k). The method also returns the matrix mathbfP_s = 0, which is useless except for  [InternalModel] estimators.\n\n\n\n\n\ninit_stochpred(estim::InternalModel, Hp)\n\nInit the stochastic prediction matrices for InternalModel.\n\nKs and Ps matrices are defined as:\n\n    mathbfY_s = mathbfK_s x_s(k) + mathbfP_s y_s(k)\n\nwith mathbfY_s as stochastic predictions from k+1 to k+H_p, current  stochastic states mathbfx_s(k) and outputs mathbfy_s(k). mathbfy_s(k) comprises the measured outputs mathbfy_s^m(k) = mathbfy^m(k) - mathbfy_d(k) and unmeasured mathbfy_s^u(k) = 0. See [1].\n\n[1]: Desbiens, A., D. Hodouin & É. Plamondon. 2000, \"Global predictive control : a unified control structure for decoupling setpoint tracking, feedforward compensation and  disturbance rejection dynamics\", IEE Proceedings - Control Theory and Applications,  vol. 147, no 4, https://doi.org/10.1049/ip-cta:20000443, p. 465–475, ISSN 1350-2379.\n\n\n\n\n\n","category":"function"},{"location":"sim_model/#Specifying-plant-models","page":"Specifying plant models","title":"Specifying plant models","text":"","category":"section"},{"location":"sim_model/","page":"Specifying plant models","title":"Specifying plant models","text":"The SimModel types represents discrete state-space models that can be used to  construct StateEstimator and PredictiveController objects, or as plant  simulators by calling evaloutput and updatestate! methods on  SimModel objects (to test estimator/controller designs). For time simulations, the  states x are stored inside SimModel objects. Use setstate! method  to manually modify them.  ","category":"page"},{"location":"sim_model/#SimModel-functions-and-types","page":"Specifying plant models","title":"SimModel functions and types","text":"","category":"section"},{"location":"sim_model/","page":"Specifying plant models","title":"Specifying plant models","text":"LinModel\nNonLinModel\nSimModel\nsetop!\nsetstate!(::SimModel,::Any)\nupdatestate!(::SimModel,::Any)\nevaloutput(::SimModel)","category":"page"},{"location":"sim_model/#ModelPredictiveControl.LinModel","page":"Specifying plant models","title":"ModelPredictiveControl.LinModel","text":"LinModel(sys::StateSpace[, Ts]; i_u=1:size(sys,2), i_d=Int[])\n\nConstruct a LinModel from state-space model sys with sampling time Ts in second.\n\nTs can be omitted when sys is discrete-time. Its state-space matrices are:\n\nbeginaligned\n    mathbfx(k+1) = mathbfA x(k) + mathbfB z(k) \n    mathbfy(k)   = mathbfC x(k) + mathbfD z(k)\nendaligned\n\nwith the state mathbfx and output mathbfy vectors. The mathbfz vector  comprises the manipulated inputs mathbfu and measured disturbances mathbfd,  in any order. i_u provides the indices of mathbfz that are manipulated, and i_d,  the measured disturbances. See Extended Help if sys is continuous-time.\n\nSee also ss, tf.\n\nExamples\n\njulia> model = LinModel(ss(0.4, 0.2, 0.3, 0, 0.1))\nDiscrete-time linear model with a sample time Ts = 0.1 s and:\n 1 manipulated inputs u\n 1 states x\n 1 outputs y\n 0 measured disturbances d\n\nExtended Help\n\nState-space matrices are similar if sys is continuous (replace mathbfx(k+1) with  mathbfx(t) and k with t on the LHS). In such a case, it's discretized with  c2d and :zoh for manipulated inputs, and :tustin, for measured disturbances. \n\nThe constructor transforms the system to a more practical form (mathbfD_u=0 because  of the zero-order hold):\n\nbeginaligned\n    mathbfx(k+1) =  mathbfA x(k) + mathbfB_u u(k) + mathbfB_d d(k) \n    mathbfy(k)   =  mathbfC x(k) + mathbfD_d d(k)\nendaligned\n\n\n\n\n\nLinModel(sys::TransferFunction[, Ts]; i_u=1:size(sys,2), i_d=Int[])\n\nConvert to minimal realization state-space when sys is a transfer function.\n\nsys is equal to fracmathbfy(s)mathbfz(s) for continuous-time, and  fracmathbfy(z)mathbfz(z), for discrete-time.\n\nExamples\n\njulia> model = LinModel([tf(3, [30, 1]) tf(-2, [5, 1])], 0.5, i_d=[2])\nDiscrete-time linear model with a sample time Ts = 0.5 s and:\n 1 manipulated inputs u\n 2 states x\n 1 outputs y\n 1 measured disturbances d\n\n\n\n\n\nLinModel(sys::DelayLtiSystem, Ts; i_u=1:size(sys,2), i_d=Int[])\n\nDiscretize with zero-order hold when sys is a continuous system with delays.\n\nThe delays must be multiples of the sample time Ts.\n\nExamples\n\njulia> model = LinModel(tf(4, [10, 1])*delay(2), 0.5)\nDiscrete-time linear model with a sample time Ts = 0.5 s and:\n 1 manipulated inputs u\n 5 states x\n 1 outputs y\n 0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"sim_model/#ModelPredictiveControl.NonLinModel","page":"Specifying plant models","title":"ModelPredictiveControl.NonLinModel","text":"NonLinModel(f, h, Ts::Real, nu::Int, nx::Int, ny::Int, nd::Int=0)\n\nConstruct a NonLinModel from discrete-time state-space functions f and h.\n\nThe state update mathbff and output mathbfh functions are defined as :\n\n    beginaligned\n    mathbfx(k+1) = mathbffBig( mathbfx(k) mathbfu(k) mathbfd(k) Big) \n    mathbfy(k)   = mathbfhBig( mathbfx(k) mathbfd(k) Big)\n    endaligned\n\nTs is the sampling time in second. nu, nx, ny and nd are the respective number of  manipulated inputs, states, outputs and measured disturbances. \n\ntip: Tip\nReplace the d argument with _ if nd = 0 (see Examples below).  \n\nNonlinear continuous-time state-space functions are not supported for now. In such a case,  manually call a differential equation solver in the f function (e.g.: Euler method).\n\nSee also LinModel.\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->-x+u, (x,_)->2x, 10, 1, 1, 1)\nDiscrete-time nonlinear model with a sample time Ts = 10.0 s and:\n 1 manipulated inputs u\n 1 states x\n 1 outputs y\n 0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"sim_model/#ModelPredictiveControl.SimModel","page":"Specifying plant models","title":"ModelPredictiveControl.SimModel","text":"Abstract supertype of LinModel and NonLinModel types.\n\n\n\n(model::SimModel)(d=Float64[])\n\nFunctor allowing callable SimModel object as an alias for evaloutput.\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->-x + u, (x,_)->x .+ 20, 10, 1, 1, 1);\n\njulia> y = model()\n1-element Vector{Float64}:\n 20.0\n\n\n\n\n\n","category":"type"},{"location":"sim_model/#ModelPredictiveControl.setop!","page":"Specifying plant models","title":"ModelPredictiveControl.setop!","text":"setop!(model::SimModel; uop=nothing, yop=nothing, dop=nothing)\n\nSet model inputs uop, outputs yop and measured disturbances dop operating points.\n\nThe state-space model with operating points (a.k.a. nominal values) is:\n\nbeginaligned\n    mathbfx(k+1) =  mathbfA x(k) + mathbfB_u u_0(k) + mathbfB_d d_0(k) \n    mathbfy_0(k) =  mathbfC x(k) + mathbfD_d d_0(k)\nendaligned\n\nwit in which the uop, yop and dop vectors evaluate :\n\nbeginaligned\n    mathbfu_0(k) = mathbfu(k) - mathbfu_op \n    mathbfy_0(k) = mathbfy(k) - mathbfy_op \n    mathbfd_0(k) = mathbfd(k) - mathbfd_op \nendaligned\n\nThe structure is similar if model is a NonLinModel:\n\nbeginaligned\n    mathbfx(k+1) = mathbffBig(mathbfx(k) mathbfu_0(k) mathbfd_0(k)Big)\n    mathbfy_0(k) = mathbfhBig(mathbfx(k) mathbfd_0(k)Big)\nendaligned\n\nExamples\n\njulia> model = setop!(LinModel(tf(3, [10, 1]), 2), uop=[50], yop=[20])\nDiscrete-time linear model with a sample time Ts = 2.0 s and:\n 1 manipulated inputs u\n 1 states x\n 1 outputs y\n 0 measured disturbances d\n\n\n\n\n\n","category":"function"},{"location":"sim_model/#ModelPredictiveControl.setstate!-Tuple{SimModel, Any}","page":"Specifying plant models","title":"ModelPredictiveControl.setstate!","text":"setstate!(model::SimModel, x)\n\nSet model.x states to values specified by x. \n\n\n\n\n\n","category":"method"},{"location":"sim_model/#ModelPredictiveControl.updatestate!-Tuple{SimModel, Any}","page":"Specifying plant models","title":"ModelPredictiveControl.updatestate!","text":"updatestate!(model::SimModel, u, d=Float64[])\n\nUpdate model.x states with current inputs u and measured disturbances d.\n\n\n\n\n\n","category":"method"},{"location":"sim_model/#ModelPredictiveControl.evaloutput-Tuple{SimModel}","page":"Specifying plant models","title":"ModelPredictiveControl.evaloutput","text":"evaloutput(model::SimModel, d=Float64[])\n\nEvaluate SimModel outputs y from model.x states and measured disturbances d.\n\n\n\n\n\n","category":"method"},{"location":"#ModelPredictiveControl.jl-Documentation","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.jl Documentation","text":"","category":"section"},{"location":"","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.jl Documentation","text":"","category":"page"},{"location":"#Tutorial","page":"ModelPredictiveControl.jl Documentation","title":"Tutorial","text":"","category":"section"},{"location":"","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.jl Documentation","text":"asd ads. API Reference","category":"page"},{"location":"#API-Reference","page":"ModelPredictiveControl.jl Documentation","title":"API Reference","text":"","category":"section"},{"location":"","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.jl Documentation","text":"","category":"page"}]
}
