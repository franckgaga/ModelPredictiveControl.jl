var documenterSearchIndex = {"docs":
[{"location":"#ModelPredictiveControl.jl-Documentation","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.jl Documentation","text":"","category":"section"},{"location":"","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.jl Documentation","text":"LinModel\nNonLinModel\nsetop!\nupdatestate\nevaloutput\ninit_internalmodel","category":"page"},{"location":"#ModelPredictiveControl.LinModel","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.LinModel","text":"LinModel(sys::StateSpace, Ts=NaN; i_u=1:size(sys,2), i_d=Int[])\n\nConstruct a LinModel from state-space model sys with sampling time Ts in second.\n\nTs can be omitted when sys is discrete-time. Its state-space matrices are:\n\nbeginalign*\n    mathbfx(k+1) = mathbfA mathbfx(k) + mathbfB mathbfz(k) \n    mathbfy(k)   = mathbfC mathbfx(k) + mathbfD mathbfz(k)\nendalign*\n\nwith the state mathbfx and output mathbfy vectors. The mathbfz vector  comprises the manipulated inputs mathbfu and measured disturbances mathbfd,  in any order. i_u provides the indices of mathbfz that are manipulated, and i_d,  the measured disturbances. The state-space matrices are similar if sys is continuous-time  (replace mathbfx(k+1) with dotmathbfx(t)). In such a case, it's discretized  with c2d and :zoh for manipulated inputs, and :tustin, for measured disturbances. \n\nThe constructor transforms the system to a more practical form (Dáµ¤ = 0 because of the  zero-order hold):\n\nbeginalign*\n    mathbfx(k+1) =  mathbfA mathbfx(k) + \n                        mathbfB_u mathbfu(k) + mathbfB_d mathbfd(k) \n    mathbfy(k)   =  mathbfC mathbfx(k) + mathbfD_d mathbfd(k)\nendalign*\n\nSee also ss, tf.\n\nExamples\n\njulia> model = LinModel(ss(0.4, 0.2, 0.3, 0, 0.1))\nDiscrete-time linear model with a sample time Ts = 0.1 s and:\n- 1 manipulated inputs u\n- 1 states x\n- 1 outputs y\n- 0 measured disturbances d\n\n\n\n\n\nLinModel(sys::TransferFunction, Ts=NaN; i_u=1:size(sys,2), i_d=Int[])\n\nConvert to minimal realization state-space when sys is a transfer function.\n\nsys is equal to fracmathbfy(s)mathbfz(s) for continuous-time, and  fracmathbfy(z)mathbfz(z), for discrete-time.\n\nExamples\n\njulia> model = LinModel([tf(3, [30, 1]) tf(-2, [5, 1])], 2, i_d=[2])\nDiscrete-time linear model with a sample time Ts = 2.0 s and:\n- 1 manipulated inputs u\n- 2 states x\n- 1 outputs y\n- 1 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"#ModelPredictiveControl.NonLinModel","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.NonLinModel","text":"NonLinModel(f, h, Ts::Real, nu::Int, nx::Int, ny::Int, nd::Int=0)\n\nConstruct a NonLinModel from discrete-time state-space functions f and h.\n\nThe state update mathbff and output mathbfh functions are defined as :\n\n    beginalign*\n    mathbfx(k+1) = mathbffBig( mathbfx(k) mathbfu(k) mathbfd(k) Big) \n    mathbfy(k)   = mathbfhBig( mathbfx(k) mathbfd(k) Big)\n    endalign*\n\nTs is the sampling time in second. nu, nx, ny and nd are the respective number of  manipulated inputs, states, outputs and measured disturbances. Replace the d argument with _ if nd=0 (see Examples below). Nonlinear continuous-time state-space functions  are not supported for the time being. In such a case, manually call a differential equation  solver in the f function (e.g.: Euler method).\n\nSee also LinModel.\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->-x+u, (x,_)->2x, 10, 1 , 1 , 1)\nDiscrete-time nonlinear model with a sample time Ts = 10.0 s and:\n- 1 manipulated inputs u\n- 1 states x\n- 1 outputs y\n- 0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"#ModelPredictiveControl.setop!","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.setop!","text":"setop!(model::SimModel; uop=Float64[], yop=Float64[], dop=Float64[])\n\nSet model inputs uop, outputs yop and measured disturbances dop operating points.\n\nThe state-space model including operating points (a.k.a. nominal values) is:\n\nbeginalign*\n    mathbfx(k+1) =  mathbfA mathbfx(k) + \n    mathbfB_u mathbfu_0(k) + mathbfB_d mathbfd_0(k) \n    mathbfy_0(k) =  mathbfC mathbfx(k) + mathbfD_d mathbfd_0(k)\nendalign*\n\nwhere\n\nbeginalign*\n    mathbfu_0(k) = mathbfu(k) - mathbfu_op(k) \n    mathbfy_0(k) = mathbfy(k) - mathbfy_op(k) \n    mathbfd_0(k) = mathbfd(k) - mathbfd_op(k) \nendalign*\n\nThe structure is similar if model is a NonLinModel:\n\nbeginalign*\n    mathbfx(k+1) = mathbffBig(mathbfx(k) mathbfu_0(k) mathbfd_0(k)Big)\n    mathbfy_0(k) = mathbfhBig(mathbfx(k) mathbfd_0(k)Big)\nendalign*\n\nExamples\n\njulia> model = LinModel(tf(3, [10, 1]), 2);\n\njulia> setop!(model, uop=[50], yop=[20])\n\n\n\n\n\n\n","category":"function"},{"location":"#ModelPredictiveControl.updatestate","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.updatestate","text":"updatestate(sys::SimModel, x, u, d=Float64[])\n\nUpdate states x of sys with current inputs u and measured disturbances d.\n\n\n\n\n\n","category":"function"},{"location":"#ModelPredictiveControl.evaloutput","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.evaloutput","text":"evaloutput(sys::SimModel, x, d=Float64[])\n\nEvaluate output y of sys with current state x and measured disturbances d.\n\n\n\n\n\n","category":"function"}]
}
