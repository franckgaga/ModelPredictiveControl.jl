var documenterSearchIndex = {"docs":
[{"location":"#ModelPredictiveControl.jl-Documentation","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.jl Documentation","text":"","category":"section"},{"location":"","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.jl Documentation","text":"LinModel\nNonLinModel","category":"page"},{"location":"#ModelPredictiveControl.LinModel","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.LinModel","text":"LinModel(sys::StateSpace, Ts::Real; <keyword arguments>)\n\nConstruct a LinModel from state-state model sys.\n\nIf sys is continuous, it is dicretized with c2d and :zoh for manipulated inputs, and :tustin, for measured disturbances.\n\nSee also ss, tf.\n\nArguments\n\nsys::StateSpace: state-space model incl. manipulated inputs and measured disturbances\nTs::Real = NaN: model sampling time in second, can be ommited if sys is discrete\ni_u::IntRangeOrVector = 1:size(sys,2): indices of sys inputs that are    manipulated\ni_d::IntRangeOrVector = Int[]: indices of sys inputs that are measured   disturbances\nu_op::Vector{<:Real} = Float64[]: manipulated input operating points\ny_op::Vector{<:Real} = Float64[]: outputs operating points\nd_op::Vector{<:Real} = Float64[]: measured disturbances operating points\n\nExamples\n\njulia> LinModel(tf(3, [10, 1]), 2, u_op=[50], y_op=[20])\nDiscrete-time linear model with a sample time Ts = 2.0 s and:\n- 1 manipulated inputs u\n- 1 states x\n- 1 outputs y\n- 0 measured disturbances d\n\n\n\n\n\nLinModel(sys::TransferFunction, Ts::Real; <keyword arguments>)\n\nConvert to minimal realization state-space when sys is a transfer function.\n\n\n\n\n\n","category":"type"},{"location":"#ModelPredictiveControl.NonLinModel","page":"ModelPredictiveControl.jl Documentation","title":"ModelPredictiveControl.NonLinModel","text":"NonLinModel(f, h, Ts::Real, nu::Int, nx::Int, ny::Int, nd::Int=0; <keyword arguments>)\n\nConstruct a NonLinModel from discrete state-state functions f and h.\n\nThe discrete state-space functions are:\n\nbeginalign*\nmathbfx(k+1) = mathbffbig( mathbfx(k) mathbfu(k) mathbfd(k) big) \nmathbfy(k)   = mathbfhbig( mathbfx(k) mathbfd(k) big)\nendalign*\n\nReplace the d argument with _ if nd = 0 (see Examples)\n\nArguments\n\nf: state update function mathbff(mathbfx(k) mathbfu(k) mathbfd(k))\nh: output function mathbfh(mathbfx(k) mathbfd(k))\nTs::Real: model sampling time in second\nnu::Int: number of manipulated inputs\nnx::Int: number of states\nny::Int: number of outpus\nnd::Int = 0: number of measured distrubances\nu_op::Vector{<:Real} = Float64[]: manipulated input operating points\ny_op::Vector{<:Real} = Float64[]: outputs operating points\nd_op::Vector{<:Real} = Float64[]: measured disturbances operating points\n\nExamples\n\njulia> NonLinModel((x,u,_)->-x+u, (x,_)->2x, 10, 1 , 1 , 1)\nDiscrete-time nonlinear model with a sample time Ts = 10.0 s and:\n- 1 manipulated inputs u\n- 1 states x\n- 1 outputs y\n- 0 measured disturbances d\n\n\n\n\n\n","category":"type"}]
}
